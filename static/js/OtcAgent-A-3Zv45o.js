import{q as l,at as g,u as A,A as e,D as o,E as d,F as i,G as h,H as u,B as w}from"./index-Ds2hFbCb.js";const F=(m=l.otcAgent)=>{const y=g(m),a=y==null?void 0:y.cns,c=y==null?void 0:y.address,p=A().getCurrentAccount();return{MIN_AMOUNT:async()=>{try{const t=await a.MIN_AMOUNT();return w(t)}catch{return 0}},PRICE_PRECISION:async()=>{try{const t=await a.PRICE_PRECISION();return w(t)}catch{return 0}},balances:async(t,r)=>{const s=r||p;try{const n=await a.balances(s,t);return w(n)}catch{return 0}},RATE_BASE:async()=>{try{return(await a.RATE_BASE()).toString()}catch{return 0}},lockBalances:async(t,r)=>{const s=r||p;try{const n=await a.lockBalances(s,t);return w(n)}catch{return 0}},mai:async()=>{try{return await a.mai()}catch(t){return t}},musd:async()=>{try{return await a.musd()}catch(t){return t}},pendingAmount:async(t,r)=>{const s=r||p;try{const n=await a.pendingAmount(e(t),s);return i(n)}catch(n){return u(n,c,"pendingAmount",{price:e(t),accountAddress:s})}},userPendingList:async t=>{const r=t||p;try{const s=await a.userPendingList(r);return i(s)}catch(s){return u(s,c,"userPendingList",{accountAddress:r})}},priceList:async t=>{try{const r=await a.priceList(t);return i(r)}catch(r){return u(r,c,"priceList",{limit:t})}},systemPendingLimit:async()=>{try{const t=await a.systemPendingLimit();return w(t)}catch{return 0}},buy:async(t,r)=>{try{const s=await(await a.buy(e(t),e(r),o)).wait();return i(s)}catch(s){return u(s,c,"buy",{price:e(t),amount:e(r),overrides:o})}},deposit:async(t,r)=>{try{const s=await(await a.deposit(t,e(r),o)).wait();return i(s)}catch(s){return u(s,c,"deposit",{token:t,toWei:e(r),overrides:o})}},revoke:async t=>{try{const r=await(await a.revoke(e(t),o)).wait();return i(r)}catch(r){return u(r,c,"revoke",{price:e(t),overrides:o})}},sell:async(t,r)=>{try{const s=await(await a.sell(e(t),e(r),o)).wait();return i(s)}catch(s){return u(s,c,"sell",{price:e(t),amount:e(r),overrides:o})}},withdraw:async(t,r)=>{try{const s=await(await a.withdraw(t,e(r),o)).wait();return i(s)}catch(s){return u(s,c,"withdraw",{token:t,amount:e(r),overrides:o})}},burnMUSD:async t=>{try{const r=await a.estimateGas.burnMusd(e(t)),n=await(await a.burnMusd(e(t),{gasLimit:d(r,1e3),...o})).wait();return i(n)}catch(r){return h(r),u(r,c,"burnMusd",{amount:e(t)})}},burnMAI:async t=>{try{const r=await a.estimateGas.burnMAI(e(t)),n=await(await a.burnMAI(e(t),{gasLimit:d(r,1e3),...o})).wait();return i(n)}catch(r){return h(r),u(r,c,"burnMAI",{amount:e(t)})}},system:async()=>{try{return await a.system()}catch(t){return t}},estimateBuy:async(t,r)=>{try{const s=await await a.estimateBuy(e(t),e(r));return i(s)}catch(s){return u(s,c,"estimateBuy",{price:e(t),amount:e(r)})}},estimateSell:async(t,r)=>{try{const s=await await a.estimateSell(e(t),e(r));return i(s)}catch(s){return u(s,c,"estimateSell",{price:e(t),amount:e(r)})}},exchangePoolWithdraw:async t=>{try{const r=await a.estimateGas.exchangePoolWithdraw(e(t)),n=await(await a.exchangePoolWithdraw(e(t),{gasLimit:d(r,1e3),...o})).wait();return i(n)}catch(r){return h(r),u(r,c,"exchangePoolWithdraw",{amount:e(t)})}}}};export{F as o};
