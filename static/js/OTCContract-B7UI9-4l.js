import{as as A,u as h,A as e,F as i,H as u,D as c,E as l,G as w,B as d}from"./index-koYZVdtr.js";const F=()=>{const m=A(),n=m==null?void 0:m.cns,o=m==null?void 0:m.address,p=h().getCurrentAccount();return{MIN_AMOUNT:async()=>{try{const t=await n.minAmount();return d(t)}catch{return 0}},PRICE_PRECISION:async()=>{try{const t=await n.PRICE_PRECISION();return d(t)}catch{return 0}},balances:async(t,r)=>{const s=r||p;try{const a=await n.balances(s,t);return d(a)}catch{return 0}},RATE_BASE:async()=>{try{return(await n.RATE_BASE()).toString()}catch{return 0}},lockBalances:async(t,r)=>{const s=r||p;try{const a=await n.lockBalances(s,t);return d(a)}catch{return 0}},mai:async()=>{try{return await n.mai()}catch(t){return t}},musd:async()=>{try{return await n.musd()}catch(t){return t}},pendingAmount:async(t,r)=>{const s=r||p;try{const a=await n.pendingAmount(e(t),s);return i(a)}catch(a){return u(a,o,"pendingAmount",{price:e(t),accountAddress:s})}},userPendingList:async t=>{const r=t||p;try{const s=await n.userPendingList(r);return i(s)}catch(s){return u(s,o,"userPendingList",{accountAddress:r})}},priceList:async t=>{try{const r=await n.priceList(t);return i(r)}catch(r){return u(r,o,"priceList",{limit:t})}},systemPendingLimit:async()=>{try{const t=await n.systemPendingLimit();return d(t)}catch{return 0}},buy:async(t,r,s)=>{const a=s||p;try{const y=await(await n.buy(e(t),e(r),a,c)).wait();return i(y)}catch(y){return w(y),u(y,o,"buy",{price:e(t),amount:e(r),accountAddress:a,overrides:c})}},deposit:async(t,r)=>{try{const s=await(await n.deposit(t,e(r),c)).wait();return i(s)}catch(s){return w(s),u(s,o,"deposit",{token:t,amount:e(r),overrides:c})}},revoke:async t=>{try{const r=await(await n.revoke(e(t),c)).wait();return i(r)}catch(r){return w(r),u(r,o,"revoke",{price:e(t),overrides:c})}},sell:async(t,r,s)=>{const a=s||p;try{const y=await(await n.sell(e(t),e(r),a,c)).wait();return i(y)}catch(y){return w(y),u(y,o,"sell",{price:e(t),amount:e(r),accountAddress:a,overrides:c})}},withdraw:async(t,r)=>{try{const s=await(await n.withdraw(t,e(r),c)).wait();return i(s)}catch(s){return w(s),u(s,o,"withdraw",{token:t,amount:e(r),overrides:c})}},burnMUSD:async()=>{const t=await n.estimateGas.burnMUSD();try{const s=(await n.burnMUSD({gasLimit:l(t,1e3),...c})).wait();return i(s)}catch(r){return w(r),u(r,o,"burnMUSD",{params1:{gasLimit:l(t,1e3),...c}})}},burnMAI:async()=>{const t=await n.estimateGas.burnMAI();try{const s=(await n.burnMAI({gasLimit:l(t,1e3),...c})).wait();return i(s)}catch(r){return w(r),u(r,o,"burnMAI",{params1:{gasLimit:l(t,1e3),...c}})}},system:async()=>{try{return await n.system()}catch(t){return t}},estimateBuy:async(t,r)=>{try{const s=await await n.estimateBuy(e(t),e(r));return i(s)}catch(s){return u(s,o,"estimateBuy",{price:e(t),amount:e(r)})}},estimateSell:async(t,r)=>{try{const s=await await n.estimateSell(e(t),e(r));return i(s)}catch(s){return u(s,o,"estimateSell",{price:e(t),amount:e(r)})}}}};export{F as o};
